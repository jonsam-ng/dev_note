# 现代浏览器工作原理
## 前言

全面的WebKit和Gecko内部操作入门是以色列开发人员Tali Garsiel所做的大量研究的结果。几年来，她回顾了有关浏览器内部的所有已发布数据（请参阅参考资料），并花费了大量时间阅读Web浏览器源代码。她写了：   

在IE占据90％统治地位的岁月里，除了将浏览器视为“黑匣子”外，没有什么可做的了，但是现在，由于开源浏览器的使用份额超过一半，现在是一个窥视的好时机引擎盖，并查看网络浏览器中的内容。好吧，里面有数百万条C ++行…… 

塔利（Tali）在她的网站上发布了她的研究，但我们知道该研究吸引了更多的读者，因此我们将其整理并重新发布在这里。 

作为Web开发人员，学习浏览器操作的内部原理可以帮助您做出更好的决策，并了解开发最佳实践背后的理由。尽管这是篇冗长的文档，但我们建议您花一些时间进行深入研究。我们保证您会很高兴。Paul Irish，Chrome开发者关系  

本文已翻译成几种语言：HTML5 Rocks托管了德语，西班牙语，日语，葡萄牙语，俄语和简体中文版本。您也可以查看韩文和土耳其文的外部托管翻译。            

您还可以观看Tali Garsiel在Vimeo 上就该主题发表演讲：   

 

## 介绍

Web浏览器是使用最广泛的软件。在本入门中，我将解释它们如何在后台工作。在地址栏中输入google.com 时，我们将看到会发生什么，直到您在浏览器屏幕上看到Google页面。  

## 目录

1. 简介          

	1. 我们将讨论的浏览器          

	2. 浏览器的主要功能          

	3. 浏览器的高层结构          

2. 渲染引擎          

	1. 渲染引擎          

	2. 主流程          

	3. 主要流程示例          

3. 解析和DOM树构造          

	1. 解析：常规          

		1. 文法          

		2. 解析器– Lexer组合          

		3. 翻译          

		4. 解析示例          

		5. 词汇和语法的形式定义          

		6. 解析器的类型          

		7. 自动生成解析器          

	2. HTML解析器          

		1. HTML语法定义          

		2. 不是上下文无关的语法          

		3. HTML DTD          

		4. DOM          

		5. 解析算法          

		6. 标记化算法          

		7. 树构建算法          

		8. 解析完成时的操作          

		9. 浏览器容错          

3. CSS解析          

	1. WebKit CSS解析器          

4. 处理脚本和样式表的顺序          

	1. 脚本          

	2. 投机解析          

	3. 样式表          

4. 渲染树结构          

	1. 与DOM树的渲染树关系          

	2. 构造树的流程          

	3. 样式计算          

		1. 共享样式数据          

		2. Firefox规则树          

			1. 分成结构          

			2. 使用规则树计算样式上下文          

		3. 操纵规则以轻松配对          

		4. 以正确的级联顺序应用规则          

			1. 样式表级联顺序          

			2. 特异性          

			3. 排序规则          

	4. 渐进过程          

5. 布局          

	1. 脏位系统          

	2. 全局和增量布局          

	3. 异步和同步布局          

	4. 优化          

	5. 布局过程          

	6. 宽度计算          

	7.换行          

6. 绘画          

	1.整体和增量          

	2. 绘画顺序          

	3. Firefox显示列表          

	4. WebKit矩形存储          

7. 动态变化          

8. 渲染引擎的线程          

	1. 事件循环    	      

9. CSS2视觉模型          

	1. 帆布          

	2. CSS盒子模型          

	3. 定位方案          

	4. 盒子类型          

	5. 定位          

		1. 相对          

		2. 浮动          

		3. 绝对和固定          

	6. 分层表示          

10. 资源       

## 我们将讨论的浏览器

如今，台式机上使用了五种主要的浏览器：Chrome，Internet Explorer，Firefox，Safari和Opera。在移动设备上，主要的浏览器是Android浏览器，iPhone，Opera Mini和Opera Mobile，UC浏览器，诺基亚S40 / S60浏览器和Chrome 。所有这些浏览器（除Opera浏览器之外）均基于WebKit。我将提供来自开源浏览器Firefox和Chrome以及Safari（部分开源）的示例。根据StatCounter的统计数据（截至2013年6月），Chrome，Firefox和Safari约占全球桌面浏览器使用量的71％。在移动设备上，Android浏览器，iPhone和Chrome占使用量的54％。  

## 浏览器的主要功能

浏览器的主要功能是`通过向服务器请求并在浏览器窗口中显示它来显示您选择的Web资源`。该资源通常是HTML文档，但也可以是PDF，图像或某些其他类型的内容。用户使用URI（统一资源标识符）指定资源的位置。

浏览器解释和显示HTML文件的方式在HTML和CSS规范中指定。这些规范由W3C （万维网联盟）组织维护，该组织是Web的标准组织。多年来，浏览器仅遵循部分规范，并开发了自己的扩展程序。这给网络作者造成了严重的兼容性问题。今天，大多数浏览器或多或少都符合规范。  

浏览器用户界面彼此之间有很多共同点。常见的用户界面元素包括：

• 地址栏，用于插入URI              

• 后退和前进按钮              

• 书签选项              

• 刷新和停止按钮，用于刷新或停止当前文档的加载              

• 主页按钮，可带您进入主页              

奇怪的是，浏览器的用户界面未在任何正式规范中指定，它只是源于多年经验中形成的良好实践以及浏览器之间的相互模仿。HTML5规范没有定义浏览器必须具有的UI元素，而是列出了一些常见的元素。其中包括地址栏，状态栏和工具栏。当然，某些浏览器（例如Firefox的下载管理器）具有独特的功能。

## 浏览器的高级结构

浏览器的主要组件是（1.1）：

1. 用户界面：包括地址栏，后退/前进按钮，书签菜单等。浏览器的每个部分都会显示，但您看到所请求页面的窗口除外。          

2. 浏览器引擎：在UI和呈现引擎之间封送动作。          

3. 渲染引擎：负责显示请求的内容。例如，如果请求的内容是HTML，则呈现引擎解析HTML和CSS，然后在屏幕上显示解析的内容。            

4. 网络：用于HTTP请求之类的网络调用，在独立于平台的界面后面针对不同平台使用不同的实现。          

5. UI后端：用于绘制基本小部件，例如组合框和窗口。该后端公开了不是平台特定的通用接口。它的下面使用操作系统用户界面方法。          

6. JavaScript解释器：用于解析和执行JavaScript代码。          

7. 数据存储：这是一个持久层。浏览器可能需要在本地保存各种数据，例如cookie。浏览器还支持存储机制，例如localStorage，IndexedDB，WebSQL和FileSystem。          

图片：浏览器组件 

请务必注意，Chrome等浏览器运行渲染引擎的多个实例：每个选项卡一个。每个选项卡在单独的过程中运行。

### 渲染引擎

呈现引擎的职责即在浏览器屏幕上显示请求的内容。

默认情况下，呈现引擎可以显示HTML和XML文档和图像。它可以通过插件或扩展程序显示其他类型的数据；例如，使用PDF查看器插件显示PDF文档。但是，在本章中，我们将重点介绍主要用例：显示使用CSS格式化的HTML和图像。

### 渲染引擎

不同的浏览器使用不同的渲染引擎：Internet Explorer使用Trident，Firefox使用Gecko，Safari使用WebKit。Chrome和Opera（版本15起）使用Blink，这是WebKit的分支。

WebKit是一个开源渲染引擎，最初是Linux平台的引擎，后来被Apple修改为支持Mac和Windows。有关更多详细信息，请参见webkit.org。  

#### 主要流程

呈现引擎将开始从网络层获取所请求文档的内容。通常将以8kB的块完成。

之后，这是渲染引擎的基本流程：

图片：渲染引擎​​基本流程 

呈现引擎将开始解析HTML文档，并将元素转换为称为“内容树”的树中的DOM节点。引擎将解析外部CSS文件和样式元素中的样式数据。样式信息以及HTML中的视觉指令将用于创建另一棵树：渲染树。   

渲染树包含具有视觉属性（如颜色和尺寸）的矩形。矩形以正确的顺序显示在屏幕上。

构建渲染树后，它将经历“ 布局 ”过程。这意味着为每个节点提供应在屏幕上显示的确切坐标。下一阶段是绘画 - 将遍历渲染树，并使用UI后端层绘画每个节点。 

重要的是要了解这是一个循序渐进的过程。为了获得更好的用户体验，渲染引擎将尝试尽快在屏幕上显示内容。它不会等到所有HTML解析完毕后才开始构建和布局渲染树。内容的一部分将被解析并显示，而该过程将继续处理其余的内容，这些其余的内容始终来自网络。

主要流程示例

图片：WebKit主流程 

图片：Mozilla的Gecko渲染引擎主要流程（3.6） 

从图3和图4中可以看到，尽管WebKit和Gecko使用的术语略有不同，但是流程基本上是相同的。

壁虎将视觉格式化元素树称为“框架树”。每个元素都是一个框架。WebKit使用术语“渲染树”，它由“渲染对象”组成。WebKit使用术语“布局”来放置元素，而Gecko则将其称为“重排”。“附件”是WebKit的术语，用于连接DOM节点和可视信息以创建渲染树。一个小的非语义差异是Gecko在HTML和DOM树之间有一个额外的层。它被称为“内容接收器”，是制造DOM元素的工厂。我们将讨论流程的每个部分：

 

解析- 一般

由于解析是渲染引擎中非常重要的过程，因此我们将对其进行更深入的研究。让我们从一些有关解析的介绍开始。

解析文档意味着将其转换为代码可以使用的结构。解析的结果通常是代表文档结构的节点树。这称为解析树或语法树。

例如，解析表达式2 + 3-1 可以返回此树：  

图片：数学表达式树节点 

文法

解析基于文档遵循的语法规则：文档所使用的语言或格式。您可以解析的每种格式都必须具有由词汇和语法规则组成的确定性语法。它称为上下文无关文法。人类语言不是这种语言，因此无法使用常规解析技术进行解析。 

解析器– Lexer组合

解析可以分为两个子过程：词法分析和语法分析。

词法分析是将输入分解为标记的过程。令牌是语言词汇：有效构件的集合。在人类语言中，它将由出现在该语言词典中的所有单词组成。

语法分析是语言语法规则的应用。

解析器通常将工作划分为两个部分：负责将输入分解为有效令牌的词法分析器（有时称为令牌生成器），以及根据语言语法规则通过分析文档结构来负责构建解析树的解析器。词法分析器知道如何去除不相关的字符，例如空格和换行符。    

图片：从源文档到解析树 

解析过程是迭代的。解析器通常会向词法分析器询问新的令牌，并尝试将令牌与语法规则之一进行匹配。如果规则匹配，则将与令牌相对应的节点添加到解析树中，解析器将请求另一个令牌。

如果没有规则匹配，则解析器将在内部存储令牌，并继续请求令牌，直到找到与所有内部存储的令牌匹配的规则。如果找不到规则，则解析器将引发异常。这意味着文档无效并且包含语法错误。

翻译

在许多情况下，解析树不是最终产品。解析通常用于翻译：将输入文档转换为另一种格式。一个例子是编译。将源代码编译为机器代码的编译器首先将其解析为解析树，然后将其转换为机器代码文档。

图片：编译流程 

解析示例

在图5中，我们根据数学表达式构建了一个解析树。让我们尝试定义一种简单的数学语言并查看解析过程。

 

词汇：我们的语言可以包括整数，加号和减号。

句法：

1. 语言语法构建块是表达式，术语和运算。          

2. 我们的语言可以包括任何数量的表达方式。          

3. 表达式定义为“项”，后跟“运算”，后跟另一个项          

4. 操作是加号或减号          

5. 术语是整数标记或表达式          

 

让我们分析输入2 + 3-1 。匹配规则的第一个子字符串是2 ：根据规则5，它是一个术语。第二个匹配项是2 + 3 ：这匹配第三个规则：项后跟一个运算符，再跟另一个项。下一场比赛只会在输入的结尾处命中。2 + 3-1 是一个表达式，因为我们已经知道2 + 3 是一个术语，因此我们有一个术语，后跟一个运算符，然后是另一个术语。2 + + 不会匹配任何规则，因此是无效输入。 
        

词汇和语法的形式定义

词汇通常用正则表达式表示。 

例如，我们的语言将被定义为：

INTEGER：0 | [ 1 - 9 ] [ 0 - 9 ] *

加号：+

减号：-

如您所见，整数是由正则表达式定义的。

 

语法通常以称为BNF的格式定义。我们的语言将定义为： 

表达式：=术语操作术语

操作：=加号| 减去

字词：=整数| 表达

 

我们说过，如果一种语言的语法是上下文无关的语法，则可以由常规解析器对其进行解析。上下文无关文法的直观定义是可以完全用BNF表示的文法。有关正式定义，请参阅Wikipedia关于上下文无关语法的文章。  

解析器的类型

解析器有两种类型：自上而下的解析器和自下而上的解析器。直观的解释是自上而下的解析器检查语法的高级结构并尝试找到规则匹配项。自下而上的解析器从输入开始，并逐渐将其转换为语法规则，从低级规则开始直到满足高级规则。

让我们看看两种类型的解析器将如何解析我们的示例。

自上而下的解析器将从更高级别的规则开始：它将标识2 + 3 作为表达式。然后，它将2 + 3-1识别为一个表达式（识别该表达式的过程在发展，与其他规则匹配，但是起点是最高级别的规则）。    

自下而上的解析器将扫描输入，直到匹配规则为止。然后它将用规则替换匹配的输入。这将一直持续到输入结束。部分匹配的表达式放置在解析器的堆栈上。

叠放

输入项

 

2 + 3-1

术语

+ 3-1

定期操作

3-1

表达

-1

表达操作

1个

表达

--

 

这种类型的自底向上解析器称为移位减少解析器，因为输入会向右移动（想象一个指针首先指向输入起点，然后向右移动），并逐渐减少为语法规则。

 

自动生成解析器

有一些可以生成解析器的工具。您向他们提供您语言的语法- 它的词汇和语法规则- 并且它们会生成一个有效的解析器。创建解析器需要对解析有深刻的理解，并且手工创建优化的解析器并不容易，因此解析器生成器会非常有用。

WebKit 使用两个众所周知的解析器生成器：Flex用于创建词法分析器，而Bison用于创建解析器（您可能会以Lex和Yacc的名称遇到它们）。Flex输入是一个包含令牌的正则表达式定义的文件。Bison的输入是BNF格式的语言语法规则。     

HTML解析器

HTML解析器的工作是将HTML标记解析为解析树。

HTML语法定义

W3C组织创建的规范中定义了HTML的词汇和语法。  

不是上下文无关的语法

正如我们在解析介绍中所看到的那样，可以使用BNF之类的格式来正式定义语法语法。

不幸的是，所有常规解析器主题都不适用于HTML（我并不是出于娱乐目的而提出它们的- 它们将用于解析CSS和JavaScript）。无法通过解析器所需的上下文无关语法轻松定义HTML。

有一种定义HTML的正式格式– DTD（文档类型定义）– 但是它不是上下文无关的语法。

乍一看似乎很奇怪。HTML非常接近XML。有很多可用的XML解析器。HTML有XML的变体– XHTML ，那么最大的区别是什么？

区别在于HTML方法更“宽容”：它使您可以忽略某些标签（然后隐式添加），或者有时省略开始或结束标签，依此类推。总体而言，它是一种“软”语法，与XML僵化而苛刻的语法相反。

这个看似很小的细节使世界变得与众不同。一方面，这是HTML如此流行的主要原因：它宽恕了您的错误并使网络作者的生活变得轻松。另一方面，这使得编写正式语法变得困难。综上所述，传统的解析器无法轻松解析HTML，因为它的语法不是上下文无关的。XML解析器无法解析HTML。

HTML DTD

HTML定义为DTD格式。此格式用于定义SGML系列的语言。该格式包含所有允许的元素，它们的属性和层次结构的定义。如前所述，HTML DTD并非形成上下文无关的语法。  

DTD有一些变体。严格模式仅符合规范，但其他模式包含对浏览器过去使用的标记的支持。目的是向后兼容旧内容。当前的严格DTD在这里：www.w3.org/TR/html4/strict.dtd 

DOM

输出树（“分析树”）是DOM元素和属性节点的树。DOM是文档对象模型的缩写。它是HTML文档的对象表示形式，是HTML元素（如JavaScript）与外界的接口。
树的根是“ Document ”对象。

DOM与标记几乎是一对一的关系。例如：

<html>

  <身体>

    <p>

      你好，世界

    </ p>

    <div> <img src = “ example.png” /> </ div>

  </ body>

</ html>

该标记将转换为以下DOM树：

 

图片：示例标记的DOM树 

像HTML一样，DOM由W3C组织指定。参见www.w3.org/DOM/DOMTR。它是用于处理文档的通用规范。特定模块描述HTML特定元素。可以在以下位置找到HTML定义：www.w3.org/TR/2003/REC-DOM-Level-2-HTML-20030109/idl-definitions.html。  

当我说树包含DOM节点时，是指树由实现DOM接口之一的元素构成。浏览器使用具体的实现，这些实现具有浏览器内部使用的其他属性。

解析算法

如前几节所述，无法使用常规的自上而下或自下而上的解析器来解析HTML。

原因如下：

1. 语言的宽容性质。          

2. 浏览器具有传统的容错能力，以支持众所周知的无效HTML情况。          

3. 解析过程是可重入的。对于其他语言，源在解析期间不会更改，但是在HTML中，动态代码（例如包含document.write（）调用的脚本元素）会添加额外的标记，因此解析过程实际上会修改输入。             

浏览器无法使用常规的解析技术，因此会创建自定义解析器来解析HTML。

的分析算法进行详细的HTML5说明书中描述。该算法包括两个阶段：令牌化和树构建。 

标记化是词法分析，将输入解析为标记。HTML标记中有开始标记，结束标记，属性名称和属性值。

令牌生成器识别令牌，将其提供给树构造器，并消耗下一个字符以识别下一个令牌，依此类推，直到输入结束。

图片：HTML解析流程（摘自HTML5规范） 

标记化算法

该算法的输出是HTML令牌。该算法表示为状态机。每个状态消耗输入流的一个或多个字符，并根据这些字符更新下一个状态。该决策受当前标记化状态和树构建状态的影响。这意味着根据当前状态，对于正确的下一个状态，相同的消耗字符将产生不同的结果。该算法太复杂而无法完整描述，因此让我们看一个简单的示例，该示例将帮助我们理解原理。

基本示例– 标记以下HTML：

<html>

  <身体>

    你好，世界

  </ body>

</ html>

初始状态为“数据状态”。当< 遇到性格，状态更改为“标记打开状态” 。消费a-z 字符会导致创建“开始标签令牌”，状态会更改为“标签名称状态” 。我们一直保持这种状态，直到使用了> 字符为止。每个字符都附加到新的令牌名称上。在我们的情况下，创建的令牌是html 令牌。          

当> 到达标签，当前令牌发出后，状态变回“数据状态” 。所述<BODY> 标记将用相同的步骤进行处理。到目前为止，已发出html 和body 标签。我们现在回到“数据状态” 。消耗Hello world 的H 字符将导致创建和发出字符标记，直到达到< of </ body> 为止。我们将为Hello world的每个角色发出一个角色标记。                   

现在我们回到“标签打开状态” 。消耗下一个输入/ 会导致创建结束标记令牌并移至“标记名称状态” 。再次，我们将保持在此状态，直到到达> 。然后将发出新的标记令牌，然后返回到“数据状态” 。的</ HTML> 输入将像前面的情况进行处理。          

图片：标记示例输入 

树构建算法

创建解析器时，将创建Document对象。在树构建阶段，将修改以文档为根的DOM树，并向其中添加元素。令牌生成器发出的每个节点将由树构造函数处理。规范为每个令牌定义了与之相关的哪个DOM元素，并将为此令牌创建。元素被添加到DOM树中，并且还添加到打开元素的堆栈中。该堆栈用于更正嵌套不匹配和未关闭的标签。该算法也被描述为状态机。这些状态称为“ 插入模式”。

让我们看一下示例输入的树构建过程：

<html>

  <身体>

    你好，世界

  </ body>

</ html>

树构建阶段的输入是来自标记化阶段的一系列标记。第一种模式是“初始模式” 。接收到“ html”令牌将导致移动到“ before html” 模式，并以该模式重新处理令牌。这将导致创建HTMLHtmlElement元素，该元素将附加到根Document对象。   

状态将更改为“在头之前” 。然后接收到“ body”令牌。尽管我们没有“ head”令牌，但会隐式创建HTMLHeadElement并将其添加到树中。 

现在，我们进入“ in head” 模式，然后进入“ after head” 。将重新处理主体令牌，创建并插入HTMLBodyElement，并将模式转移到“ in body” 。    

现在，已收到“ Hello world”字符串的字符标记。第一个将导致创建和插入“文本”节点，其他字符将附加到该节点。

接收到主体结束令牌将导致转移到“后主体” 模式。现在，我们将收到html结束标签，该标签将使我们进入“后身体之后” 模式。接收到文件令牌的结尾将结束解析。    

图片：示例html的树结构 

解析完成时的操作

在此阶段，浏览器将文档标记为交互式文档，并开始解析处于“延迟”模式的脚本：应在文档解析后执行的脚本。然后将文档状态设置为“完成”，并触发“加载”事件。

您可以在HTML5规范中看到用于标记化和树构建的完整算法 

浏览器的容错能力

在HTML页面上，您永远不会收到“无效语法”错误。浏览器会修复所有无效内容，然后继续。

以以下HTML为例：

<html>

  <mytag>

  </ mytag>

  <div>

  <p>

  </ div>

    真的很烂的HTML

  </ p>

</ html>

我一定违反了大约一百万条规则（“ mytag”不是标准标签，“ p”和“ div”元素的错误嵌套等等），但是浏览器仍然正确显示它并且没有抱怨。因此，很多解析器代码都在修复HTML作者的错误。

错误处理在浏览器中非常一致，但是令人惊讶的是，它还没有成为HTML规范的一部分。像书签和后退/前进按钮一样，这只是多年来在浏览器中开发的东西。在许多站点上都有重复的已知无效HTML构造，浏览器尝试以与其他浏览器一致的方式对其进行修复。

HTML5规范确实定义了其中一些要求。（WebKit在HTML解析器类的开头的注释中很好地总结了这一点。）

解析器将标记化的输入解析到文档中，从而建立文档树。如果文档格式正确，则对其进行解析很简单。

不幸的是，我们必须处理许多格式不正确的HTML文档，因此解析器必须容忍错误。

我们必须至少照顾以下错误情况：

1. 明确禁止在某些外部标签内添加要添加的元素。在这种情况下，我们应将所有标签关闭到禁止该元素的标签，然后再添加。          

2. 我们不允许直接添加元素。可能是写文档的人忘记了中间的一些标签（或者中间的标签是可选的）。以下标记可能就是这种情况：HTML HEAD BODY TBODY TR TD LI（我忘了吗？）。          

3. 我们想在一个内联元素中添加一个block元素。关闭所有内联元素，直到下一个较高的block元素。          

4. 如果这样做无济于事，请关闭元素，直到允许我们添加元素– 或忽略标签。          

让我们看一些WebKit容错示例：

</br>而不是<br>

有些网站使用</br>而不是<br>。为了与IE和Firefox兼容，WebKit将其视为<br>。
代码：

如果（t-> isCloseTag（brTag）&& m_document-> inCompatMode（））{

     reportError（MalformedBRError ）;

     t-> beginTag = true ;

}

请注意，错误处理是内部的：它不会呈现给用户。

 

流浪表

杂散表是另一个表内部的表，而不是表单元格内部的表。

例如：

<表格>

    <表格>

        <tr> <td> 内部表</ td> </ tr>

    </ table>

    <tr> <td> 外部表</ td> </ tr>

</ table>

WebKit会将层次结构更改为两个同级表：

<表格>

    <tr> <td> 外部表</ td> </ tr>

</ table>

<表格>

    <tr> <td> 内部表</ td> </ tr>

</ table>

代码：

如果（m_inStrayTableContent && localName == tableTag）

        popBlock（tableTag）;

WebKit使用堆栈作为当前元素的内容：它将内部表从外部表堆栈中弹出。这些表现在将成为同级。

 

嵌套表单元素

如果用户将一个表单放在另一个表单中，则忽略第二个表单。
代码：

如果（！m_currentFormElement）{

        m_currentFormElement = 新的HTMLFormElement （formTag，m_document）;

}

 

标签层次太深

评论不言自明。
 

www.liceo.edu.mx是一个网站的示例，该网站通过一堆<b>都实现了大约1500个标签的嵌套级别。在最多一起忽略它们之前，我们最多只允许20个相同类型的嵌套标签。

布尔HTMLParser :: allowNestedRedundantTag（const AtomicString ＆tagName）

{

 

无符号i = 0 ;

为（HTMLStackElem * curr = m_blockStack;

         我<cMaxRedundantTagDepth && curr && curr-> tagName == tagName;

     curr = curr-> next ，i ++）{}

返回我！= cMaxRedundantTagDepth;

}

 

放错位置的html或主体末端标签

再次- 评论不言而喻。

支持真正损坏的HTML。我们永远不会关闭body标签，因为一些愚蠢的网页会在文档实际结束之前关闭它。让我们依靠end（）调用来关闭事物。

如果（t-> tagName == htmlTag || t-> tagName == bodyTag）

        回报;

因此，网页制作者要小心- 除非你想出现在Webkit容错的代码片段的例子- 写良好的HTML。

 

 

CSS解析

还记得引言中的解析概念吗？嗯，与HTML不同，CSS是一种上下文无关的语法，可以使用引言中介绍的解析器类型进行解析。实际上，CSS规范定义了CSS词汇和语法语法。 

让我们看一些例子：
词汇语法（词汇）由每个标记的正则表达式定义：

注释\ / \ * [^ *] * \ * +（[^ / *] [^ *] * \ * +）* \ /

num [0-9] + | [0-9] *“。” [0-9] +

nonascii [\ 200- \ 377]

nmstart [_a-z] | {nonascii} | {escape}

nmchar [_a-z0-9-] | {nonascii} | {转义}

名称{nmchar} +

ident {nmstart} {nmchar} *

“ ident”是标识符的缩写，例如类名。“ name”是元素ID（由“＃”引用）

语法语法在BNF中进行了描述。

规则集

  ：选择器[ '，' S *选择器] *

    '{' S *声明[ ';' S *声明] * '}' S *

  ;

选择器

  ：simple_selector [组合选择器| S + [组合器？选择器]？]？

  ;

simple_selector

  ：element_name [哈希| 类 属性| 伪] *

  | [哈希| 类 属性| 伪] +

  ;

类

  ：'。' 身份

  ;

element_name

  ：IDENT | '*'

  ;

属性

  ：'[' S * IDENT S * [[ '=' | 包含| 破折号] S *

    [IDENT | STRING] S *] ']'

  ;

伪的

  ：'：' [IDENT | 功能S * [IDENT S *] '）' ]

  ;

说明：规则集是以下结构：

div.error，a.error {

  颜色：红色

  font-weight ：bold;

}

div.error和a.error是选择器。花括号内的部分包含此规则集所应用的规则。此结构在此定义中正式定义：

规则集

  ：选择器[ '，' S *选择器] *

    '{' S *声明[ ';' S *声明] * '}' S *

  ;

这意味着规则集是一个选择器，或者是多个选择器，用逗号和空格分隔（S代表空白）。规则集包含花括号，并在其中包含一个声明或可选的多个用分号分隔的声明。“声明”和“选择器”将在以下BNF定义中定义。

 

WebKit CSS解析器

WebKit使用Flex和Bison解析器生成器从CSS语法文件自动创建解析器。您可以从解析器介绍中回顾到，Bison创建了一个自底向上的移位减少解析器。Firefox使用手动编写的自上而下的解析器。在这两种情况下，每个CSS文件都被解析为StyleSheet对象。每个对象都包含CSS规则。CSS规则对象包含选择器和声明对象，以及与CSS语法相对应的其他对象。  

图片：解析CSS 

处理脚本和样式表的顺序

剧本

网络模型是同步的。作者希望脚本在解析器到达<script>标记后立即被解析并执行。文档的解析将暂停，直到脚本执行完毕。如果脚本是外部的，则必须首先从网络中获取资源- 这也必须同步进行，并且解析将暂停，直到获取资源为止。这是多年的模型，并且也在HTML4和5规范中指定。作者可以将“ defer”属性添加到脚本中，在这种情况下，该属性不会停止文档解析，而是在文档解析后执行。HTML5添加了将脚本标记为异步的选项，因此它将由其他线程进行解析和执行。

投机解析

WebKit和Firefox都进行了此优化。在执行脚本时，另一个线程会解析文档的其余部分，并找出需要从网络中加载哪些其他资源并进行加载。这样，可以在并行连接上加载资源，并提高了整体速度。注：投机解析器只会解析像外部脚本，样式表和图片外部资源的引用：它不会修改DOM树- 这是留给主分析器。

样式表

另一方面，样式表具有不同的模型。从概念上讲，由于样式表不会更改DOM树，因此没有理由等待它们并停止文档解析。但是，在文档解析阶段，脚本要求样式信息是一个问题。如果尚未加载和解析样式，脚本将得到错误的答案，这显然会引起很多问题。这似乎是一个极端的情况，但很常见。当样式表仍在加载和解析时，Firefox将阻止所有脚本。WebKit仅在脚本尝试访问可能受卸载的样式表影响的某些样式属性时才阻止脚本。

渲染树结构

在构建DOM树时，浏览器将构建另一棵树，即渲染树。该树按显示顺序显示视觉元素。它是文档的视觉表示。该树的目的是使内容按正确的顺序绘制。

Firefox将渲染树中的元素称为“框架”。WebKit使用术语渲染器或渲染对象。
渲染器知道如何布局并绘制自身及其子级。
WebKit的RenderObject类是渲染器的基类，具有以下定义：

类RenderObject {

  虚拟void layout（）;

  虚拟虚空Paint（PaintInfo ）;

  虚拟虚无矩形repaintRect（）;

  节点*节点;  // DOM节点

  RenderStyle *样式；  //计算出的样式

  RenderLayer * containsgLayer; //包含的z-index层

}

 

每个渲染器代表一个通常与节点的CSS框相对应的矩形区域，如CSS2规范所述。它包括几何信息，例如宽度，高度和位置。
框类型受与节点相关的样式属性的“显示”值影响（请参见样式计算部分）。这是WebKit代码，用于根据显示属性确定应为DOM节点创建哪种类型的渲染器：  

RenderObject * RenderObject ::: createObject（Node *节点，RenderStyle *样式）

{

    Document * doc =节点-> document（）;

    RenderArena *竞技场= doc-> renderArena（）;

    ...

    RenderObject * o = 0 ;

 

    开关（style-> display（））{

        情况无：

            休息;

        案例INLINE：

            o = 新的（竞技场）RenderInline （节点）；

            休息;

        案例块：

            o = 新的（竞技场）RenderBlock （节点）；

            休息;

        案例INLINE_BLOCK：

            o = 新的（竞技场）RenderBlock （节点）；

            休息;

        情况LIST_ITEM：

            o = 新的（竞技场）RenderListItem （节点）；

            休息;

       ...

    }

 

    返回o；

}

还考虑元素类型：例如，表单控件和表具有特殊框架。

在WebKit中，如果一个元素想要创建一个特殊的渲染器，它将覆盖createRenderer（）方法。渲染器指向包含非几何信息的样式对象。  

 

渲染树与DOM树的关系

渲染器对应于DOM元素，但关系不是一对一的。非可视DOM元素将不会插入渲染树中。一个示例是“ head”元素。同样，其显示值分配为“ none”的元素也不会出现在树中（而可见性为“ hidden”的元素将出现在树中）。

 

有DOM元素对应于几个视觉对象。这些通常是结构复杂的元素，无法用单个矩形描述。例如，“ select”元素具有三个渲染器：一个用于显示区域，一个用于下拉列表框，一个用于按钮。同样，当由于宽度不足一行而将文本分成多行时，新行将添加为额外的渲染器。
多个渲染器的另一个示例是损坏的HTML。根据CSS规范，内联元素必须仅包含块元素或内联元素。对于混合内容，将创建匿名块渲染器以包装内联元素。

一些渲染对象对应于DOM节点，但不在树中的同一位置。浮动元素和绝对定位的元素已不复存在，它们被放置在树的不同部分，并映射到真实框架。占位符框架是应该放置的位置。

图片：渲染树和相应的DOM树（3.1）。“视口”是最初的包含块。在WebKit中，它将是“ RenderView”对象 

构造树的流程

在Firefox中，演示文稿已注册为DOM更新的侦听器。演示文稿将框架创建委托给FrameConstructor ，构造函数解析样式（请参阅样式计算）并创建框架。   

在WebKit中，解决样式和创建渲染器的过程称为“附件”。每个DOM节点都有一个“ attach”方法。附件是同步的，将节点插入DOM树将调用新节点的“ attach”方法。

处理html和body标签将导致渲染树根的构建。根渲染对象与CSS规范所称的contains块相对应：包含所有其他块的最上面的块。它的尺寸是视口：浏览器窗口显示区域的尺寸。Firefox将其称为ViewPortFrame，而WebKit将其称为RenderView 。这是文档指向的渲染对象。树的其余部分构造为DOM节点插入。   

请参阅有关处理模型的CSS2规范。 

样式计算

构建渲染树需要计算每个渲染对象的视觉属性。这是通过计算每个元素的样式属性来完成的。

该样式包括各种来源的样式表，内联样式元素和HTML中的视觉属性（例如“ bgcolor”属性）。后者将转换为匹配的CSS样式属性。

样式表的起源是浏览器的默认样式表，页面作者提供的样式表和用户样式表– 这些是浏览器用户提供的样式表（浏览器可让您定义自己喜欢的样式。例如，在Firefox中，可以通过将样式表放置在“ Firefox个人资料”文件夹中来完成）。

样式计算带来了一些困难：

1. 样式数据是一个非常大的结构，包含大量样式属性，这可能会导致内存问题。            

2. 如果未对每个元素查找匹配规则，则可能导致性能问题。遍历每个元素的整个规则列表以找到匹配项是一项艰巨的任务。选择器可能具有复杂的结构，可能导致匹配过程从一个看似有希望的途径开始，但事实证明这是徒劳的，必须尝试另一种途径。例如– 此复合选择器：div div div div {            


3.   ...          

4. } 表示规则适用于3 div的后代<div> 。假设您要检查规则是否适用于给定的<div> 元素。您选择树上的某个路径进行检查。您可能需要遍历节点树只是为了发现只有两个div而该规则不适用。然后，您需要尝试树中的其他路径。          
    

5. 应用规则涉及相当复杂的级联规则，这些规则定义了规则的层次结构。            

让我们看看浏览器如何面对这些问题：

共享样式数据

WebKit节点引用样式对象（RenderStyle）。在某些情况下，节点可以共享这些对象。节点是兄弟姐妹或表亲，并且：

1. 元素必须处于相同的鼠标状态（例如，一个不能处于：hover状态，而另一个不能处于：hover状态）          

2. 两个元素都不应具有ID          

3. 标签名称应匹配          

4. 类属性应该匹配          

5. 映射属性集必须相同          

6. 链接状态必须匹配          

7. 焦点状态必须匹配          

8. 两个元素都不应该受到属性选择器的影响，其中受影响的定义为具有在属性选择器中的任何位置都使用属性选择器的任何选择器匹配项          

9. 元素上必须没有内联样式属性          

10. 绝对不能使用任何同级选择器。当遇到任何同级选择器时，WebCore会简单地引发全局切换，并在存在整个文档时禁用样式共享。这包括+选择器和：first-child和：last-child之类的选择器。       

Firefox规则树

Firefox还有另外两棵树可以简化样式计算：规则树和样式上下文树。WebKit也有样式对象，但是它们不像样式上下文树一样存储在树中，只有DOM节点指向其相关样式。

图片：Firefox样式上下文树（2.2） 

样式上下文包含最终值。通过以正确的顺序应用所有匹配规则并执行将其从逻辑值转换为具体值的操作来计算值。例如，如果逻辑值是屏幕的百分比，它将被计算并转换为绝对单位。规则树的想法真的很聪明。它允许在节点之间共享这些值，以避免再次计算它们。这也节省了空间。

所有匹配的规则都存储在树中。路径中的底部节点具有更高的优先级。该树包含找到的规则匹配的所有路径。懒惰地存储规则。并不是在每个节点的开始都计算树，但是每当需要计算节点样式时，就会将计算出的路径添加到树中。

想法是将树路径视为词典中的单词。假设我们已经计算出此规则树：



假设我们需要为内容树中的另一个元素匹配规则，并找出匹配的规则（以正确的顺序）是BEI。我们已经在树中有了此路径，因为我们已经计算了路径ABEIL。现在，我们要做的工作更少了。

 

让我们看看这棵树如何拯救我们的工作。

划分为结构

样式上下文分为结构。这些结构包含特定类别（如边框或颜色）的样式信息。结构中的所有属性都是继承的或不继承的。继承的属性是从元素的父元素继承而来的属性，除非由元素定义。如果未定义，则非继承属性（称为“重置”属性）将使用默认值。

该树通过在树中缓存整个结构（包含计算的最终值）来帮助我们。这个想法是，如果底部节点未提供结构的定义，则可以使用较高节点中的缓存结构。

使用规则树计算样式上下文

在计算某个元素的样式上下文时，我们首先在规则树中计算路径或使用现有路径。然后，我们开始在路径中应用规则以在我们的新样式上下文中填充结构。我们从路径的底部节点开始- 优先级最高的节点（通常是最特定的选择器），然后遍历树直到结构满为止。如果在该规则节点中没有针对该结构的规范，那么我们可以进行极大的优化- 我们沿着树上走，直到找到一个完全指定它的节点，然后简单地指向它- 这是最佳的优化- 整个结构都被共享。这样可以节省最终值和内存的计算。
如果我们找到部分定义，我们将沿着树走直到结构被填充。

如果我们没有为我们的结构找到任何定义，那么，如果该结构是“继承”类型，我们将在上下文树中指向父级的结构。在这种情况下，我们也成功共享了结构。如果是重置结构，则将使用默认值。 

如果最特定的节点确实添加了值，那么我们需要做一些额外的计算以将其转换为实际值。然后，我们将结果缓存在树节点中，以便子级可以使用它。

如果元素具有指向同一个树节点的兄弟姐妹或兄弟，则可以在它们之间共享整个样式上下文。  

让我们看一个例子：假设我们有这个HTML

<html>

  <身体>

    <div class = “ err” id = “ div1” >

      <p>

        这是<span class = “ big” > 大错误</ span>

        这也是

        <span class = “ big” > 非常大的错误</ span> 错误

      </ p>

    </ div>

    <div class = “ err” id = “ div2” > 另一个错误</ div>

  </ body>

</ html>

以及以下规则：

1. div { margin ：5px ; 颜色：黑色}          

2. .err { color ：red}          

3. .big { margin-top ：3px }          

4. div span { margin-bottom ：4px }          

5. ＃div1 { color ：blue}          

6. ＃div2 { color ：green}          

为了简化起见，假设我们只需要填写两个结构：颜色结构和边距结构。color结构仅包含一个成员：color margin结构包含四个面。
生成的规则树如下所示（节点标记有节点名称：它们指向的规则编号）：

图片：规则树 

 

上下文树如下所示（节点名称：它们指向的规则节点）：

图片：上下文树 

假设我们解析HTML并获得第二个<div>标记。我们需要为此节点创建样式上下文并填充其样式结构。
我们将匹配这些规则，并发现<div>的匹配规则是1、2和6。这意味着树中已经存在一个可供我们的元素使用的路径，我们只需要为其添加另一个节点即可。规则6（规则树中的节点F）。
我们将创建一个样式上下文并将其放入上下文树中。新样式的上下文将指向规则树中的节点F。

现在，我们需要填充样式结构。我们将从填写保证金结构开始。由于最后一个规则节点（F）不会添加到margin结构中，因此我们可以沿着树上升，直到找到在上一个节点插入中计算出的缓存结构并使用它为止。我们将在节点B上找到它，节点B是指定保证金规则的最高节点。

我们确实为color结构定义了，因此我们不能使用缓存的结构。由于颜色具有一个属性，因此我们不需要上树来填充其他属性。我们将计算结束值（将字符串转换为RGB等），并将计算的结构缓存在此节点上。

第二个<span>元素的工作更加容易。我们将匹配规则，并得出结论，它指向规则G，就像之前的跨度一样。由于我们的兄弟姐妹指向同一节点，因此我们可以共享整个样式上下文，而仅指向先前范围的上下文。

对于包含从父级继承的规则的结构，缓存是在上下文树上完成的（color属性实际上是继承的，但是Firefox将其视为reset并将其缓存在规则树上）。
例如，如果我们在段落中添加了字体规则：

p {font-family：Verdana ; 字体大小：10px ；字体粗细：粗体}

然后，段落元素（它是上下文树中div的子元素）可以与父元素共享相同的字体结构。如果没有为段落指定字体规则。

 

在没有规则树的WebKit中，匹配的声明将遍历四次。首先应用非重要的高优先级属性（应首先应用这些属性，因为其他属性依赖于它们，例如显示），然后是高优先级重要，然后是普通优先级不重要，然后是普通优先级重要规则。这意味着将根据正确的级联顺序解析多次出现的属性。最后的胜利。
 

总结一下：共享样式对象（全部或其中的某些结构）可以解决问题1和3。Firefox规则树还有助于以正确的顺序应用属性。   

轻松匹配规则

样式规则有多种来源：

• CSS规则，可以在外部样式表中或在样式元素中。p {颜色：蓝色}              
 

• 内联样式属性，例如<p style = “ color ：blue ” />              
 

• HTML视觉属性（映射到相关的样式规则）<p bgcolor = “ blue” />              
 

最后两个很容易与该元素匹配，因为他拥有样式属性，并且可以使用该元素作为键来映射HTML属性。

如之前在第2期中所述，CSS规则匹配可能比较棘手。为了解决该难题，对规则进行了操作以使其更易于访问。 

解析样式表后，根据选择器，将规则添加到多个哈希图之一。有按名称，按类名，按标签名的地图以及不属于这些类别的所有内容的一般地图。如果选择器是一个ID，则规则将被添加到ID映射中；如果它是一个类，则它将被添加到类映射中，以此类推。
这种操作使匹配规则变得更加容易。无需查看每个声明：我们可以从地图中提取元素的相关规则。这种优化消除了95％以上的规则，因此甚至在匹配过程中也无需考虑它们（4.1）。

让我们来看例如以下样式规则：

p.error {颜色：红色}

#messageDiv {高度：50px}

div {margin：5px }

第一条规则将插入到类映射中。第二个进入id映射，第三个进入标签映射。

对于以下HTML片段；

<p class = “错误” > 发生错误</ p>

<div id = “ messageDiv” > 这是一条消息</ div>

 

我们将首先尝试为p元素找到规则。类映射将包含一个“错误”键，在该键下可以找到“ p.error”的规则。div元素在id映射（键为id）和标签映射中具有相关规则。因此，剩下的唯一工作就是找出由键提取的哪些规则真正匹配。
例如，如果div的规则是

表div {边距：5px }

它仍然会从标签映射中提取出来，因为键是最右边的选择器，但是它与我们没有表祖先的div元素不匹配。

 

WebKit和Firefox都执行此操作。

以正确的级联顺序应用规则

样式对象具有与每个视觉属性（所有CSS属性，但更通用）相对应的属性。如果该属性未由任何匹配规则定义，则某些属性可以被父元素样式对象继承。其他属性具有默认值。

当定义不止一个时，问题就开始了- 这是解决问题的级联顺序。

样式表级联顺序

样式属性的声明可以出现在多个样式表中，并且可以多次出现在样式表中。这意味着应用规则的顺序非常重要。这称为“级联”命令。根据CSS2规范，级联顺序为（从低到高）：

1. 浏览器声明          

2. 用户正常声明          

3. 作者正常声明          

4. 撰写重要声明          

5. 用户重要声明          

 

浏览器声明的重要性最低，并且仅当声明被标记为重要时，用户才覆盖作者。具有相同顺序的声明将按特定性排序，然后指定它们的顺序。HTML视觉属性被转换为匹配的CSS声明。它们被视为具有低优先级的作者规则。  

特异性

选择器的特异性由CSS2规范定义，如下所示：  

• 如果声明的来源是'style'属性而不是带有选择器的规则，则计数1，否则计数0（= a）              

• 计算选择器中ID属性的数量（= b）              

• 计算选择器中其他属性和伪类的数量（= c）              

• 计算选择器中元素名称和伪元素的数量（= d）              

将四个数字abcd（在基数较大的数字系统中）连接起来可得出特异性。

 

您需要使用的数字基数由您在其中一种类别中拥有的最高计数定义。
例如，如果a = 14，则可以使用十六进制基数。在a = 17的极少数情况下，您将需要一个17位数字的基数。稍后的情况可能会发生如下选择器：html body div div p ...（选择器中有17个标签。.不太可能）。

一些例子：

* {}  / * a = 0 b = 0 c = 0 d = 0->特异性= 0,0,0,0 * /

li {}  / * a = 0 b = 0 c = 0 d = 1->特异性= 0,0,0,1 * /

li：第一行{}  / * a = 0 b = 0 c = 0 d = 2->特异性= 0,0,0,2 * /

ul li {}  / * a = 0 b = 0 c = 0 d = 2->特异性= 0,0,0,2 * /

ul ol + li {}  / * a = 0 b = 0 c = 0 d = 3->特异性= 0,0,0,3 * /

h1 + * [rel = up] {}  / * a = 0 b = 0 c = 1 d = 1->特异性= 0,0,1,1 * /

ul ol li.red {}  / * a = 0 b = 0 c = 1 d = 3->特异性= 0,0,1,3 * /

li.red.level {}  / * a = 0 b = 0 c = 2 d = 1->特异性= 0,0,2,1 * /

＃x34y {} / * a = 0 b = 1 c = 0 d = 0->特异性= 0,1,0,0 * /

style = “” / * a = 1 b = 0 c = 0 d = 0->特异性= 1,0,0,0 * /         

 

排序规则

匹配规则后，将根据级联规则对它们进行排序。WebKit对小列表使用冒泡排序，对大列表使用合并排序。WebKit通过覆盖规则的“>”运算符来实现排序：

静态布尔运算符>（CSSRuleData ＆r1，CSSRuleData ＆r2）

{

    int spec1 = r1.selector（）-> specificity（）;

    int spec2 = r2.selector（）-> specificity（）;

    return （spec1 == spec2）：r1.position（）> r2.position（）：spec1> spec2;

}

 

渐进的过程

WebKit使用一个标志来标记是否已加载所有顶级样式表（包括@imports）。如果在附加样式时未完全加载样式，则使用占位符并将其标记在文档中，并且在样式表加载后将重新计算它们。

布局

创建渲染器并将其添加到树时，它没有位置和大小。计算这些值称为布局或重排。

HTML使用基于流的布局模型，这意味着大多数时候都可以单次计算几何。``在流程中''后面的元素通常不会影响在``流程中''前面的元素的几何形状，因此布局可以在文档中从左到右，从上到下进行。有例外：例如，HTML表可能需要多次通过（3.5）。

坐标系相对于根框架。使用左上角坐标。

布局是一个递归过程。它始于根渲染器，该渲染器对应于HTML文档的<html> 元素。布局通过部分或全部框架层次结构递归地继续，为需要它的每个渲染器计算几何信息。  

根渲染器的位置为0,0，其尺寸为视口- 浏览器窗口的可见部分。

所有渲染器都有一个“布局”或“重排”方法，每个渲染器都调用需要布局的子级的布局方法。

脏位系统

为了不对每个小的更改都进行完整的布局，浏览器使用“脏位”系统。更改或添加的渲染器将自身及其子级标记为“脏”：需要布局。

有两个标志：“脏”和“子项脏”，这意味着尽管渲染器本身可能还不错，但它至少有一个子级需要布局。

全局布局和增量布局

可以在整个渲染树上触发布局- 这是“全局”布局。发生这种情况的原因可能是：

1. 会影响所有渲染器的全局样式更改，例如字体大小更改。          

2. 由于调整了屏幕大小          

 

布局可以是增量的，仅布局肮脏的渲染器（这可能会造成一些损坏，这需要额外的布局）。
渲染器变脏时（异步）触发增量布局。例如，当多余的内容来自网络并被添加到DOM树之后，新的渲染器被追加到渲染树中。

图：增量布局– 仅布局肮脏的渲染器及其子对象（3.6） 

异步和同步布局

增量布局是异步完成的。Firefox将“重排命令”排队以进行增量布局，并且调度程序将触发这些命令的批量执行。WebKit还具有一个执行增量布局的计时器- 遍历树，并布局“脏”渲染器。

要求样式信息的脚本（例如“ offsetHeight”）可以同步触发增量布局。

全局布局通常将同步触发。

有时，由于某些属性（例如滚动位置）已更改，因此在初始布局后将布局作为回调触发。

最佳化

当布局由“调整大小”或渲染器位置（而非大小）的更改触发时，渲染大小将从缓存中获取，而不进行重新计算。

在某些情况下，仅修改子树，并且布局不是从根开始的。如果更改是局部的且不影响周围环境，例如在文本字段中插入文本（否则每次击键都会触发从根开始的布局），则可能会发生这种情况。

 

布局过程

布局通常具有以下模式：

1. 父级渲染器确定其自己的宽度。          

2. 父母照顾孩子，并：          

1. 放置子渲染器（设置其x和y）。          

2. 必要时调用子布局- 它们很脏或我们处于全局布局，或由于其他原因- 计算子的身高。          

3. 父级使用子项的累积高度以及边距和填充的高度来设置自己的高度- 父级渲染器的父级将使用此高度。          

4.将其脏位设置为false。          

 

Firefox使用“状态”对象（nsHTMLReflowState）作为布局参数（称为“重排”）。该状态尤其包括父母的宽度。
Firefox布局的输出是一个“指标”对象（nsHTMLReflowMetrics）。它将包含渲染器计算的高度。

宽度计算

使用容器块的宽度，渲染器的样式“ wi​​dth”属性，边距和边框来计算渲染器的宽度。
例如以下div的宽度：

<div style = “ width ：30％” />

将由WebKit通过以下方式计算（类RenderBox方法calcWidth）：

• 容器宽度是容器availableWidth和0的最大值。在这种情况下，availableWidth是contentWidth，其计算公式为：clientWidth（）-paddingLeft（）-paddingRight（）clientWidth和clientHeight表示对象的内部，不包括边框和滚动条。              

• 元素的宽度是“宽度”样式属性。通过计算容器宽度的百分比将其计算为绝对值。              

• 现在添加了水平边框和填充。              

到目前为止，这是“首选宽度”的计算。现在将计算最小和最大宽度。

如果首选宽度大于最大宽度，则使用最大宽度。如果小于最小宽度（最小的不可破坏单位），则使用最小宽度。

 

如果需要布局，则会缓存这些值，但宽度不会改变。

 

换行

当位于布局中间的渲染器决定需要中断时，该渲染器将停止并传播到需要中断的布局的父级。父级创建额外的渲染器并在其上调用布局。

绘画

在绘画阶段，遍历渲染树，并调用渲染器的“ paint（）”方法以在屏幕上显示内容。绘画使用UI基础结构组件。

全局和增量

像布局一样，绘制也可以是全局的- 整个树都可以绘制- 或增量绘制。在增量绘画中，某些渲染器的更改方式不会影响整个树。更改的渲染器会使屏幕上的矩形无效。这导致操作系统将其视为“脏区域”并生成“绘制”事件。操作系统巧妙地将其合并为一个区域。在Chrome中，它更复杂，因为渲染器与主进程不在同一进程中。Chrome在某种程度上模拟了操作系统的行为。演示文稿侦听这些事件，并将消息委托给渲染根。遍历该树，直到到达相关渲染器为止。它将重新绘制自身（通常是其子级）。

绘画顺序

CSS2定义了绘制过程的顺序。这实际上是在堆叠上下文中堆叠元素的顺序。由于堆栈是从背面到正面绘制的，因此此顺序会影响绘制。块渲染器的堆叠顺序为： 

1. 背景色          

2. 背景图片          

3. 边框          

4. 孩子          

5. 概述          

 

Firefox显示清单

Firefox越过了渲染树，并为绘制的矩形构建了一个显示列表。它按正确的绘制顺序包含与矩形相关的渲染器（渲染器的背景，然后是边框等）。这样一来，只需要遍历一次树即可进行重新绘制，而无需多次遍历- 绘制所有背景，然后绘制所有图像，然后绘制所有边框等。

Firefox通过不添加将被隐藏的元素（例如完全位于其他不透明元素下面的元素）来优化流程。

WebKit矩形存储

在重新绘制之前，WebKit会将旧矩形另存为位图。然后，它仅绘制新矩形和旧矩形之间的增量。

动态变化

浏览器尝试尽可能少地响应更改。因此，更改元素的颜色只会导致元素的重新绘制。元素位置的更改将导致元素，其子元素以及可能的同级元素的布局和重新绘制。添加DOM节点将导致该节点的布局和重新绘制。重大更改（例如增加“ html”元素的字体大小）将导致缓存无效，重新布局和重新绘制整个树。

渲染引擎的线程

呈现引擎是单线程的。除网络操作外，几乎所有事情都在一个线程中发生。在Firefox和Safari中，这是浏览器的主线程。在Chrome中，它是制表符进程的主线程。

网络操作可以由多个并行线程执行。并行连接的数量是有限的（通常为2 – 6个连接）。

事件循环

浏览器主线程是一个事件循环。这是一个无限循环，可保持进程正常运行。它等待事件（例如布局和绘制事件）并处理它们。这是主事件循环的Firefox代码：

而（！mExiting）

    NS_ProcessNextEvent（thread）;

CSS2视觉模型

帆布

根据CSS2规范，“画布”一词描述了“呈现格式结构的空间”：浏览器在其中绘制内容的空间。画布对于空间的每个尺寸都是无限的，但是浏览器会根据视口的尺寸选择初始宽度。 

根据www.w3.org/TR/CSS2/zindex.html，如果画布包含在另一个画布中，则该画布是透明的；如果不包含，则为浏览器定义颜色。 

CSS Box模型

的CSS盒模型描述了为在文档树元件产生并根据该可视化格式模型中规定的矩形框。每个框都有一个内容区域（例如，文本，图像等）以及可选的周围填充，边框和边距区域。  

图片：CSS2盒子模型 

每个节点生成0..n这样的框。
所有元素都具有“显示”属性，该属性确定将要生成的框的类型。例子：

block：生成一个阻止框。

内联：生成一个或多个内联框。

无：无箱中产生。

默认值为内联，但浏览器样式表可能会设置其他默认值。例如：“ div”元素的默认显示为块。

您可以在此处找到默认样式表示例：www.w3.org/TR/CSS2/sample.html 

 

定位方案

共有三种方案：

1. 正常：根据对象在文档中的位置放置对象。这意味着它在渲染树中的位置就像在DOM树中的位置，并根据其框类型和尺寸进行布局          

2. 浮动：首先像正常流动一样布置对象，然后将其尽可能向左或向右移动          

3. 绝对：将对象放置在渲染树中与DOM树中不同的位置          

 

定位方案由“ position”属性和“ float”属性设置。

• 静态和相对引起正常流量              

• 绝对和固定导致绝对定位              

 

在静态定位中，未定义任何位置，并且使用默认定位。在其他方案中，作者指定位置：顶部，底部，左侧，右侧。

 

包装盒的放置方式取决于：

• 箱型              

• 箱子尺寸              

• 定位方案              

• 外部信息，例如图像尺寸和屏幕尺寸              

 

箱型

块框：形成一个块– 在浏览器窗口中具有自己的矩形。

图片：方块盒 

内联框：没有自己的块，但是在包含块内。

图片：嵌入式框 

块是一个接一个地垂直格式化的。内联被水平格式化。

图片：块和内联格式 

内联框放置在行或“行框”内。线是至少一样高最高的盒，还可以更高，当盒被对准“基线” - 意味着元素的底部部分在其它的另一个框，然后底部的一个点被对准。如果容器宽度不足，则将内联放置在几行上。这通常是段落中发生的情况。

图：线

定位方式

相对的

相对定位– 像往常一样定位，然后移动所需的增量。

图：相对定位

浮点数

浮动框移到行的左侧或右侧。有趣的功能是其他盒子在它周围流动。HTML：

<p>

  <img style = “ float ：right ” src = “ images / image.gif” width = “ 100” height = “ 100” >

  Lorem ipsum dolor坐在amet，秘密...

</ p>

看起来像：

 

图片：浮动 

绝对和固定

无论正常流程如何，都将精确定义布局。元素不参与正常流程。尺寸是相对于容器的。在固定状态下，容器是视口。

图片：固定位置 

 

注意：即使滚动文档，固定框也不会移动！

 

分层表示

这由z-index CSS属性指定。它表示框的第三维：沿“ z轴”的位置。

这些盒子分为堆栈（称为堆栈上下文）。在每个堆栈中，后面的元素将首先被绘制，而前面的元素将在顶部，更靠近用户。在重叠的情况下，最前面的元素将隐藏前一个元素。堆栈根据z-index属性排序。具有“ z-index”属性的框形成本地堆栈。视口具有外部堆栈。  

例：

<style type = “ text / css” >

      div {

        位置：绝对；

        左：2 英寸;

        顶部：2 英寸;

      }

</ style>

 

<p>

    <div

         style = “ z-index ：3 ; background-color ：red; 宽度：1in ; height ：1in ; ” >

    </ div>

    <div

         样式= “ z-index ：1 ；背景色：绿色；宽度：2in ；高度：2in ；” >

    </ div>

</ p>

结果将是这样的：

 

图片：固定位置 

尽管红色div在标记中先于绿色div，并且在常规流中之前已被绘制，但是z-index属性较高，因此在根框所持有的堆栈中其位置更靠前。

资源资源

1. 浏览器架构          

1. Grosskurth，艾伦。Web浏览器的参考体系结构（pdf）            

2. 古普塔，维尼特。浏览器如何工作– 第1部分– 体系结构            

2. 解析          

1. Aho，Sethi，Ullman，《编译器：原理，技术和工具》（又名《龙书》），Addison-Wesley，1986年          

2. 里克·杰利夫。The Bold and the Beautiful：HTML 5的两个新草案。            

3. 火狐          

1. L. David Baron，《更快的HTML和CSS：Web开发人员的布局引擎内部》。            

2. L. David Baron，《更快的HTML和CSS：面向Web开发人员的布局引擎内部》（Google技术演讲视频）            

3. Mozilla的布局引擎 L. David Baron            

4. L. David Baron，Mozilla样式系统文档            

5. 克里斯·沃特森，HTML重排笔记            

6. 壁虎概述克里斯·沃特森            

7. Alexander Larsson，HTML HTTP请求的生命周期            

4. WebKit          

1. David Hyatt，实施CSS（第1部分）            

2. David Hyatt，WebCore概述            

3. David Hyatt，WebCore渲染            

4. David Hyatt，FOUC问题            

5. W3C规格          

1. HTML 4.01规范          

2. W3C HTML5规范          

3. 级联样式表2级修订1（CSS 2.1）规范          

6. 浏览器构建说明          

1. Firefox。https://developer.mozilla.org/en/Build_Documentation            

2. WebKit。http://webkit.org/building/build.html            



Tali Garsiel是以色列的开发商。她于2000年开始从事网络开发，并熟悉Netscape的“邪恶”层模型。就像理查德·费恩曼（Richard Feynmann）一样，她着迷于了解事物的工作原理，因此她开始研究浏览器内部并记录发现的内容。Tali还发布了有关客户端性能的简短指南。  

 

## 渲染引擎

### 

## 解析与构造DOM树

## 构造渲染树

## 布局

## 绘制

## 动态变化

## 渲染引擎的线程

## CSS2视图模型

## 资源

